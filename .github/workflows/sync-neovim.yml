name: Sync GitLab Releases

on:
  schedule:
    - cron: '0 0 * * *'  # 每天午夜运行一次
  workflow_dispatch:  # 允许手动触发

jobs:
  sync-gitlab-releases:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout GitHub repository
        uses: actions/checkout@v2

      - name: Fetch Latest GitLab Release
        env:
          GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
        run: |
          # GitLab 项目的 API URL（替换为你的项目 ID）
          GITLAB_PROJECT_ID="362"  # GitLab 项目 ID
          GITLAB_API_URL="https://gitlab.b-data.ch/api/v4/projects/$GITLAB_PROJECT_ID/releases"
          https://gitlab.b-data.ch/api/v4/projects/362/releases
          
          # 获取最新的 Release 版本信息
          release_info=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$GITLAB_API_URL" | jq '.[0]')  # 仅获取最新的 Release
          release_tag=$(echo "$release_info" | jq -r '.tag_name')
          release_asset_url=$(echo "$release_info" | jq -r '.assets.sources[0].url')

          # 创建一个 releases 文件夹以存储下载的文件
          mkdir -p releases

          # 下载最新的 Release 文件
          curl -sL --header "PRIVATE-TOKEN: $GITLAB_TOKEN" "$release_asset_url" -o "releases/nvim-linux-arm64.tar.gz"

      - name: Upload to GitHub Releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # GitHub 自动提供
        run: |
          # 检查是否已有相同 tag 的 Release
          existing_release=$(gh release view "$release_tag" || echo "not found")
          
          # 如果没有相同 tag，则创建新的 Release
          if [[ "$existing_release" == "not found" ]]; then
            gh release create "$release_tag" ./releases/nvim-linux-arm64.tar.gz --title "Neovim $release_tag" --notes "Synchronized from GitLab"
          else
            echo "Release $release_tag already exists on GitHub, skipping creation."
          fi
